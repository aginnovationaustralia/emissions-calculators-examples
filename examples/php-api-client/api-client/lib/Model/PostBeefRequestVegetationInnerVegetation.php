<?php
/**
 * PostBeefRequestVegetationInnerVegetation
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AIA Calculator API
 *
 * Emissions Calculators for various farming activities
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@aginnovationaustralia.com.au
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * PostBeefRequestVegetationInnerVegetation Class Doc Comment
 *
 * @category Class
 * @description Inputs required for non-productive vegetation in order to calculate carbon sequestration
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class PostBeefRequestVegetationInnerVegetation implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'post_beef_request_vegetation_inner_vegetation';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'region' => 'string',
        'tree_species' => 'string',
        'soil' => 'string',
        'area' => 'float',
        'age' => 'float'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'region' => null,
        'tree_species' => null,
        'soil' => null,
        'area' => null,
        'age' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'region' => false,
        'tree_species' => false,
        'soil' => false,
        'area' => false,
        'age' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'region' => 'region',
        'tree_species' => 'treeSpecies',
        'soil' => 'soil',
        'area' => 'area',
        'age' => 'age'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'region' => 'setRegion',
        'tree_species' => 'setTreeSpecies',
        'soil' => 'setSoil',
        'area' => 'setArea',
        'age' => 'setAge'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'region' => 'getRegion',
        'tree_species' => 'getTreeSpecies',
        'soil' => 'getSoil',
        'area' => 'getArea',
        'age' => 'getAge'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const REGION_SOUTH_WEST = 'South West';
    public const REGION_PILBARA = 'Pilbara';
    public const REGION_KIMBERLEY = 'Kimberley';
    public const REGION_CENTRAL_WEST = 'Central West';
    public const REGION_SOUTH_COASTAL = 'South Coastal';
    public const REGION_GOLDFIELDS_EUCLA = 'Goldfields/Eucla';
    public const REGION_GASCOYNE = 'Gascoyne';
    public const REGION_CENTRAL_WHEAT_BELT = 'Central Wheat Belt';
    public const REGION_INTERIOR = 'Interior';
    public const REGION_NORTH_COAST = 'North Coast';
    public const REGION_SOUTH_COAST = 'South Coast';
    public const REGION_NORTHERN_TABLELANDS = 'Northern Tablelands';
    public const REGION_SOUTHERN_TABLELANDS = 'Southern Tablelands';
    public const REGION_NORTHERN_WHEAT_SHEEP = 'Northern Wheat/Sheep';
    public const REGION_SOUTHERN_WHEAT_SHEEP = 'Southern Wheat/Sheep';
    public const REGION_WESTERN = 'Western';
    public const REGION_NORTH_EAST = 'North East';
    public const REGION_EAST_COAST = 'East Coast';
    public const REGION_CENTRAL_NORTH_MIDLANDS_SOUTH_EAST = 'Central North/Midlands/South East';
    public const REGION_CENTRAL_PLATEAU_DERWENT_VALLEY = 'Central Plateau/Derwent Valley';
    public const REGION_WEST_SOUTH_COAST = 'West/South Coast';
    public const REGION_NORTH_WEST = 'North West';
    public const REGION_SOUTH_EAST = 'South East';
    public const REGION_MURRAY = 'Murray';
    public const REGION_MID_NORTH_FLINDERS = 'Mid-North/Flinders';
    public const REGION_PASTORAL = 'Pastoral';
    public const REGION_WEST_COAST_EYRE = 'West Coast/Eyre';
    public const REGION_MALLEE = 'Mallee';
    public const REGION_WIMMERA = 'Wimmera';
    public const REGION_NORTHERN_COUNTRY = 'Northern Country';
    public const REGION_NORTH_EAST_VIC = 'North East Vic';
    public const REGION_EAST_GIPPSLAND = 'East Gippsland';
    public const REGION_WEST_SOUTH_GIPPSLAND = 'West/South Gippsland';
    public const REGION_CENTRAL = 'Central';
    public const REGION_SOUTH_WEST_VIC = 'South West Vic';
    public const REGION_CENTRAL_HIGHLANDS_NORTHERN = 'Central Highlands/Northern';
    public const REGION_CENTRAL_WEST_FLINDERS = 'Central West/Flinders';
    public const REGION_CHANNEL_COUNTRY = 'Channel Country';
    public const REGION_MARANOA_WARREGO = 'Maranoa/Warrego';
    public const REGION_DARLING_DOWNS_BURNETT = 'Darling Downs/Burnett';
    public const REGION_NORTH_WEST_GULF = 'North West/Gulf';
    public const REGION_DARWIN_DALY = 'Darwin-Daly';
    public const REGION_ARNHEM_ROPER = 'Arnhem-Roper';
    public const REGION_VICTORIA_RIVER_TENNANT_CREEK = 'Victoria River-TennantCreek';
    public const REGION_ALICE_SPRINGS = 'Alice Springs';
    public const TREE_SPECIES_MIXED_SPECIES__ENVIRONMENTAL_PLANTINGS = 'Mixed species (Environmental Plantings)';
    public const TREE_SPECIES_NO_TREE_DATA_AVAILABLE = 'No tree data available';
    public const TREE_SPECIES_TASMANIAN_BLUE_GUM = 'Tasmanian Blue Gum';
    public const TREE_SPECIES_SPOTTED_GUM = 'Spotted Gum';
    public const TREE_SPECIES_SUGAR_GUM = 'Sugar Gum';
    public const TREE_SPECIES_HOOP_PINE = 'Hoop Pine';
    public const TREE_SPECIES_SYDNEY_BLUE_GUM = 'Sydney Blue Gum';
    public const TREE_SPECIES_DUNNS_WHITE_GUM = 'Dunn\'s White Gum';
    public const TREE_SPECIES_SHINING_GUM = 'Shining Gum';
    public const TREE_SPECIES_PINUS_RADIATA = 'Pinus Radiata';
    public const TREE_SPECIES_LEMON_SCENTED_GUM = 'Lemon-scented Gum';
    public const TREE_SPECIES_MARITIME_PINE = 'Maritime Pine';
    public const TREE_SPECIES_FLOODED_GUM = 'Flooded Gum';
    public const TREE_SPECIES_RED_IRONBARK = 'Red Ironbark';
    public const TREE_SPECIES_RADIATA_PINE__LOW_INPUT = 'Radiata Pine (low input)';
    public const TREE_SPECIES_MOUNTAIN_ASH = 'Mountain Ash';
    public const TREE_SPECIES_WESTERN_WHITE_GUM = 'Western White Gum';
    public const TREE_SPECIES_SLASH_PINE = 'Slash Pine';
    public const TREE_SPECIES_RADIATA_PINE__HIGH_INPUT = 'Radiata Pine (high input)';
    public const TREE_SPECIES_PINUS_RADIATA__LOW_INPUT = 'Pinus Radiata (low input)';
    public const TREE_SPECIES_BLACKBUTT = 'Blackbutt';
    public const TREE_SPECIES_LOBLOLLY_PINE = 'Loblolly Pine';
    public const TREE_SPECIES_PINUS_RADIATA__HIGH_INPUT = 'Pinus Radiata (high input)';
    public const TREE_SPECIES_PINUS_HYBRIDS = 'Pinus Hybrids';
    public const SOIL_LOAMS__CLAYS = 'Loams & Clays';
    public const SOIL_NO_SOIL___TREE_DATA_AVAILABLE = 'No Soil / Tree data available';
    public const SOIL_COLOURED_SANDS = 'Coloured Sands';
    public const SOIL_DUPLEX = 'Duplex';
    public const SOIL_CLAY = 'Clay';
    public const SOIL_OTHER_SOILS = '"Other Soils"';
    public const SOIL_OTHER_SOILS2 = 'Other Soils';
    public const SOIL_DUPLEX_SOILS = 'Duplex Soils';
    public const SOIL_SANDY_SOILS = 'Sandy Soils';
    public const SOIL_CALCAROSOLS = 'Calcarosols';
    public const SOIL_GREY_CRACKING_CLAYS = 'Grey Cracking Clays';
    public const SOIL_RED_EARTHS = 'Red Earths';
    public const SOIL_NON_CRACKING_CLAYS = 'Non-cracking Clays';
    public const SOIL_RED_DUPLEX = 'Red Duplex';
    public const SOIL_CRACKING_CLAYS = 'Cracking Clays';
    public const SOIL_CLAYS = 'Clays';
    public const SOIL_CLAY_GIDGEE = 'Clay Gidgee';
    public const SOIL_CLAY__BRIGALO_AND_BELAH = 'Clay (Brigalo and Belah)';
    public const SOIL_KANDOSOLS = 'Kandosols';
    public const SOIL_SANDY_DUPLEXES = 'Sandy Duplexes';
    public const SOIL_CLAY__RED_LOAM = 'Clay & Red Loam';
    public const SOIL_LOAM = 'Loam';
    public const SOIL_STRUCTURED_EARTHS = 'Structured Earths';
    public const SOIL_LOAMY_SOILS = 'Loamy Soils';
    public const SOIL_YELLOW_DUPLEX = 'Yellow Duplex';
    public const SOIL_GRADATIONAL_SOILS = 'Gradational soils';
    public const SOIL_OPEN_DOWNS = 'Open Downs';
    public const SOIL_DUPLEX_WOODLAND = 'Duplex Woodland';
    public const SOIL_EARTHS = 'Earths';
    public const SOIL_TENOSOLS = 'Tenosols';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRegionAllowableValues()
    {
        return [
            self::REGION_SOUTH_WEST,
            self::REGION_PILBARA,
            self::REGION_KIMBERLEY,
            self::REGION_CENTRAL_WEST,
            self::REGION_SOUTH_COASTAL,
            self::REGION_GOLDFIELDS_EUCLA,
            self::REGION_GASCOYNE,
            self::REGION_CENTRAL_WHEAT_BELT,
            self::REGION_INTERIOR,
            self::REGION_NORTH_COAST,
            self::REGION_SOUTH_COAST,
            self::REGION_NORTHERN_TABLELANDS,
            self::REGION_SOUTHERN_TABLELANDS,
            self::REGION_NORTHERN_WHEAT_SHEEP,
            self::REGION_SOUTHERN_WHEAT_SHEEP,
            self::REGION_WESTERN,
            self::REGION_NORTH_EAST,
            self::REGION_EAST_COAST,
            self::REGION_CENTRAL_NORTH_MIDLANDS_SOUTH_EAST,
            self::REGION_CENTRAL_PLATEAU_DERWENT_VALLEY,
            self::REGION_WEST_SOUTH_COAST,
            self::REGION_NORTH_WEST,
            self::REGION_SOUTH_EAST,
            self::REGION_MURRAY,
            self::REGION_MID_NORTH_FLINDERS,
            self::REGION_PASTORAL,
            self::REGION_WEST_COAST_EYRE,
            self::REGION_MALLEE,
            self::REGION_WIMMERA,
            self::REGION_NORTHERN_COUNTRY,
            self::REGION_NORTH_EAST_VIC,
            self::REGION_EAST_GIPPSLAND,
            self::REGION_WEST_SOUTH_GIPPSLAND,
            self::REGION_CENTRAL,
            self::REGION_SOUTH_WEST_VIC,
            self::REGION_CENTRAL_HIGHLANDS_NORTHERN,
            self::REGION_CENTRAL_WEST_FLINDERS,
            self::REGION_CHANNEL_COUNTRY,
            self::REGION_MARANOA_WARREGO,
            self::REGION_DARLING_DOWNS_BURNETT,
            self::REGION_NORTH_WEST_GULF,
            self::REGION_DARWIN_DALY,
            self::REGION_ARNHEM_ROPER,
            self::REGION_VICTORIA_RIVER_TENNANT_CREEK,
            self::REGION_ALICE_SPRINGS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTreeSpeciesAllowableValues()
    {
        return [
            self::TREE_SPECIES_MIXED_SPECIES__ENVIRONMENTAL_PLANTINGS,
            self::TREE_SPECIES_NO_TREE_DATA_AVAILABLE,
            self::TREE_SPECIES_TASMANIAN_BLUE_GUM,
            self::TREE_SPECIES_SPOTTED_GUM,
            self::TREE_SPECIES_SUGAR_GUM,
            self::TREE_SPECIES_HOOP_PINE,
            self::TREE_SPECIES_SYDNEY_BLUE_GUM,
            self::TREE_SPECIES_DUNNS_WHITE_GUM,
            self::TREE_SPECIES_SHINING_GUM,
            self::TREE_SPECIES_PINUS_RADIATA,
            self::TREE_SPECIES_LEMON_SCENTED_GUM,
            self::TREE_SPECIES_MARITIME_PINE,
            self::TREE_SPECIES_FLOODED_GUM,
            self::TREE_SPECIES_RED_IRONBARK,
            self::TREE_SPECIES_RADIATA_PINE__LOW_INPUT,
            self::TREE_SPECIES_MOUNTAIN_ASH,
            self::TREE_SPECIES_WESTERN_WHITE_GUM,
            self::TREE_SPECIES_SLASH_PINE,
            self::TREE_SPECIES_RADIATA_PINE__HIGH_INPUT,
            self::TREE_SPECIES_PINUS_RADIATA__LOW_INPUT,
            self::TREE_SPECIES_BLACKBUTT,
            self::TREE_SPECIES_LOBLOLLY_PINE,
            self::TREE_SPECIES_PINUS_RADIATA__HIGH_INPUT,
            self::TREE_SPECIES_PINUS_HYBRIDS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSoilAllowableValues()
    {
        return [
            self::SOIL_LOAMS__CLAYS,
            self::SOIL_NO_SOIL___TREE_DATA_AVAILABLE,
            self::SOIL_COLOURED_SANDS,
            self::SOIL_DUPLEX,
            self::SOIL_CLAY,
            self::SOIL_OTHER_SOILS,
            self::SOIL_OTHER_SOILS2,
            self::SOIL_DUPLEX_SOILS,
            self::SOIL_SANDY_SOILS,
            self::SOIL_CALCAROSOLS,
            self::SOIL_GREY_CRACKING_CLAYS,
            self::SOIL_RED_EARTHS,
            self::SOIL_NON_CRACKING_CLAYS,
            self::SOIL_RED_DUPLEX,
            self::SOIL_CRACKING_CLAYS,
            self::SOIL_CLAYS,
            self::SOIL_CLAY_GIDGEE,
            self::SOIL_CLAY__BRIGALO_AND_BELAH,
            self::SOIL_KANDOSOLS,
            self::SOIL_SANDY_DUPLEXES,
            self::SOIL_CLAY__RED_LOAM,
            self::SOIL_LOAM,
            self::SOIL_STRUCTURED_EARTHS,
            self::SOIL_LOAMY_SOILS,
            self::SOIL_YELLOW_DUPLEX,
            self::SOIL_GRADATIONAL_SOILS,
            self::SOIL_OPEN_DOWNS,
            self::SOIL_DUPLEX_WOODLAND,
            self::SOIL_EARTHS,
            self::SOIL_TENOSOLS,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('region', $data ?? [], null);
        $this->setIfExists('tree_species', $data ?? [], null);
        $this->setIfExists('soil', $data ?? [], null);
        $this->setIfExists('area', $data ?? [], null);
        $this->setIfExists('age', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['region'] === null) {
            $invalidProperties[] = "'region' can't be null";
        }
        $allowedValues = $this->getRegionAllowableValues();
        if (!is_null($this->container['region']) && !in_array($this->container['region'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'region', must be one of '%s'",
                $this->container['region'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['tree_species'] === null) {
            $invalidProperties[] = "'tree_species' can't be null";
        }
        $allowedValues = $this->getTreeSpeciesAllowableValues();
        if (!is_null($this->container['tree_species']) && !in_array($this->container['tree_species'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'tree_species', must be one of '%s'",
                $this->container['tree_species'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['soil'] === null) {
            $invalidProperties[] = "'soil' can't be null";
        }
        $allowedValues = $this->getSoilAllowableValues();
        if (!is_null($this->container['soil']) && !in_array($this->container['soil'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'soil', must be one of '%s'",
                $this->container['soil'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['area'] === null) {
            $invalidProperties[] = "'area' can't be null";
        }
        if ($this->container['age'] === null) {
            $invalidProperties[] = "'age' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets region
     *
     * @return string
     */
    public function getRegion()
    {
        return $this->container['region'];
    }

    /**
     * Sets region
     *
     * @param string $region The rainfall region that the vegetation is in
     *
     * @return self
     */
    public function setRegion($region)
    {
        if (is_null($region)) {
            throw new \InvalidArgumentException('non-nullable region cannot be null');
        }
        $allowedValues = $this->getRegionAllowableValues();
        if (!in_array($region, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'region', must be one of '%s'",
                    $region,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['region'] = $region;

        return $this;
    }

    /**
     * Gets tree_species
     *
     * @return string
     */
    public function getTreeSpecies()
    {
        return $this->container['tree_species'];
    }

    /**
     * Sets tree_species
     *
     * @param string $tree_species The species of tree
     *
     * @return self
     */
    public function setTreeSpecies($tree_species)
    {
        if (is_null($tree_species)) {
            throw new \InvalidArgumentException('non-nullable tree_species cannot be null');
        }
        $allowedValues = $this->getTreeSpeciesAllowableValues();
        if (!in_array($tree_species, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'tree_species', must be one of '%s'",
                    $tree_species,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tree_species'] = $tree_species;

        return $this;
    }

    /**
     * Gets soil
     *
     * @return string
     */
    public function getSoil()
    {
        return $this->container['soil'];
    }

    /**
     * Sets soil
     *
     * @param string $soil The soil type the tree is in
     *
     * @return self
     */
    public function setSoil($soil)
    {
        if (is_null($soil)) {
            throw new \InvalidArgumentException('non-nullable soil cannot be null');
        }
        $allowedValues = $this->getSoilAllowableValues();
        if (!in_array($soil, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'soil', must be one of '%s'",
                    $soil,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['soil'] = $soil;

        return $this;
    }

    /**
     * Gets area
     *
     * @return float
     */
    public function getArea()
    {
        return $this->container['area'];
    }

    /**
     * Sets area
     *
     * @param float $area The area of trees, in ha (hectares)
     *
     * @return self
     */
    public function setArea($area)
    {
        if (is_null($area)) {
            throw new \InvalidArgumentException('non-nullable area cannot be null');
        }
        $this->container['area'] = $area;

        return $this;
    }

    /**
     * Gets age
     *
     * @return float
     */
    public function getAge()
    {
        return $this->container['age'];
    }

    /**
     * Sets age
     *
     * @param float $age The age of the trees, in years
     *
     * @return self
     */
    public function setAge($age)
    {
        if (is_null($age)) {
            throw new \InvalidArgumentException('non-nullable age cannot be null');
        }
        $this->container['age'] = $age;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


