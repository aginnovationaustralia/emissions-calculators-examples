<?php
/**
 * GAFApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AIA Calculator API
 *
 * Emissions Calculators for various farming activities
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@aginnovationaustralia.com.au
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * GAFApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class GAFApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'postAquaculture' => [
            'application/json',
        ],
        'postBeef' => [
            'application/json',
        ],
        'postBuffalo' => [
            'application/json',
        ],
        'postCotton' => [
            'application/json',
        ],
        'postDairy' => [
            'application/json',
        ],
        'postDeer' => [
            'application/json',
        ],
        'postFeedlot' => [
            'application/json',
        ],
        'postGoat' => [
            'application/json',
        ],
        'postGrains' => [
            'application/json',
        ],
        'postHorticulture' => [
            'application/json',
        ],
        'postPork' => [
            'application/json',
        ],
        'postPoultry' => [
            'application/json',
        ],
        'postProcessing' => [
            'application/json',
        ],
        'postRice' => [
            'application/json',
        ],
        'postSheep' => [
            'application/json',
        ],
        'postSheepbeef' => [
            'application/json',
        ],
        'postSugar' => [
            'application/json',
        ],
        'postVineyard' => [
            'application/json',
        ],
        'postWildcatchfishery' => [
            'application/json',
        ],
        'postWildseafisheries' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation postAquaculture
     *
     * Perform aquaculture calculation
     *
     * @param  \OpenAPI\Client\Model\PostAquacultureRequest $post_aquaculture_request post_aquaculture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postAquaculture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostAquaculture200Response
     */
    public function postAquaculture($post_aquaculture_request, string $contentType = self::contentTypes['postAquaculture'][0])
    {
        list($response) = $this->postAquacultureWithHttpInfo($post_aquaculture_request, $contentType);
        return $response;
    }

    /**
     * Operation postAquacultureWithHttpInfo
     *
     * Perform aquaculture calculation
     *
     * @param  \OpenAPI\Client\Model\PostAquacultureRequest $post_aquaculture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postAquaculture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostAquaculture200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAquacultureWithHttpInfo($post_aquaculture_request, string $contentType = self::contentTypes['postAquaculture'][0])
    {
        $request = $this->postAquacultureRequest($post_aquaculture_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostAquaculture200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostAquaculture200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostAquaculture200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postAquacultureAsync
     *
     * Perform aquaculture calculation
     *
     * @param  \OpenAPI\Client\Model\PostAquacultureRequest $post_aquaculture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postAquaculture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAquacultureAsync($post_aquaculture_request, string $contentType = self::contentTypes['postAquaculture'][0])
    {
        return $this->postAquacultureAsyncWithHttpInfo($post_aquaculture_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAquacultureAsyncWithHttpInfo
     *
     * Perform aquaculture calculation
     *
     * @param  \OpenAPI\Client\Model\PostAquacultureRequest $post_aquaculture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postAquaculture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAquacultureAsyncWithHttpInfo($post_aquaculture_request, string $contentType = self::contentTypes['postAquaculture'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostAquaculture200Response';
        $request = $this->postAquacultureRequest($post_aquaculture_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAquaculture'
     *
     * @param  \OpenAPI\Client\Model\PostAquacultureRequest $post_aquaculture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postAquaculture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postAquacultureRequest($post_aquaculture_request, string $contentType = self::contentTypes['postAquaculture'][0])
    {

        // verify the required parameter 'post_aquaculture_request' is set
        if ($post_aquaculture_request === null || (is_array($post_aquaculture_request) && count($post_aquaculture_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_aquaculture_request when calling postAquaculture'
            );
        }


        $resourcePath = '/aquaculture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_aquaculture_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_aquaculture_request));
            } else {
                $httpBody = $post_aquaculture_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBeef
     *
     * Perform beef calculation
     *
     * @param  \OpenAPI\Client\Model\PostBeefRequest $post_beef_request post_beef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBeef'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostBeef200Response
     */
    public function postBeef($post_beef_request, string $contentType = self::contentTypes['postBeef'][0])
    {
        list($response) = $this->postBeefWithHttpInfo($post_beef_request, $contentType);
        return $response;
    }

    /**
     * Operation postBeefWithHttpInfo
     *
     * Perform beef calculation
     *
     * @param  \OpenAPI\Client\Model\PostBeefRequest $post_beef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBeef'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostBeef200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBeefWithHttpInfo($post_beef_request, string $contentType = self::contentTypes['postBeef'][0])
    {
        $request = $this->postBeefRequest($post_beef_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostBeef200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostBeef200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostBeef200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postBeefAsync
     *
     * Perform beef calculation
     *
     * @param  \OpenAPI\Client\Model\PostBeefRequest $post_beef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBeef'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBeefAsync($post_beef_request, string $contentType = self::contentTypes['postBeef'][0])
    {
        return $this->postBeefAsyncWithHttpInfo($post_beef_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBeefAsyncWithHttpInfo
     *
     * Perform beef calculation
     *
     * @param  \OpenAPI\Client\Model\PostBeefRequest $post_beef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBeef'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBeefAsyncWithHttpInfo($post_beef_request, string $contentType = self::contentTypes['postBeef'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostBeef200Response';
        $request = $this->postBeefRequest($post_beef_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBeef'
     *
     * @param  \OpenAPI\Client\Model\PostBeefRequest $post_beef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBeef'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postBeefRequest($post_beef_request, string $contentType = self::contentTypes['postBeef'][0])
    {

        // verify the required parameter 'post_beef_request' is set
        if ($post_beef_request === null || (is_array($post_beef_request) && count($post_beef_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_beef_request when calling postBeef'
            );
        }


        $resourcePath = '/beef';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_beef_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_beef_request));
            } else {
                $httpBody = $post_beef_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBuffalo
     *
     * Perform buffalo calculation
     *
     * @param  \OpenAPI\Client\Model\PostBuffaloRequest $post_buffalo_request post_buffalo_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBuffalo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostBuffalo200Response
     */
    public function postBuffalo($post_buffalo_request, string $contentType = self::contentTypes['postBuffalo'][0])
    {
        list($response) = $this->postBuffaloWithHttpInfo($post_buffalo_request, $contentType);
        return $response;
    }

    /**
     * Operation postBuffaloWithHttpInfo
     *
     * Perform buffalo calculation
     *
     * @param  \OpenAPI\Client\Model\PostBuffaloRequest $post_buffalo_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBuffalo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostBuffalo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBuffaloWithHttpInfo($post_buffalo_request, string $contentType = self::contentTypes['postBuffalo'][0])
    {
        $request = $this->postBuffaloRequest($post_buffalo_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostBuffalo200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostBuffalo200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostBuffalo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postBuffaloAsync
     *
     * Perform buffalo calculation
     *
     * @param  \OpenAPI\Client\Model\PostBuffaloRequest $post_buffalo_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBuffalo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBuffaloAsync($post_buffalo_request, string $contentType = self::contentTypes['postBuffalo'][0])
    {
        return $this->postBuffaloAsyncWithHttpInfo($post_buffalo_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBuffaloAsyncWithHttpInfo
     *
     * Perform buffalo calculation
     *
     * @param  \OpenAPI\Client\Model\PostBuffaloRequest $post_buffalo_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBuffalo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBuffaloAsyncWithHttpInfo($post_buffalo_request, string $contentType = self::contentTypes['postBuffalo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostBuffalo200Response';
        $request = $this->postBuffaloRequest($post_buffalo_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBuffalo'
     *
     * @param  \OpenAPI\Client\Model\PostBuffaloRequest $post_buffalo_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBuffalo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postBuffaloRequest($post_buffalo_request, string $contentType = self::contentTypes['postBuffalo'][0])
    {

        // verify the required parameter 'post_buffalo_request' is set
        if ($post_buffalo_request === null || (is_array($post_buffalo_request) && count($post_buffalo_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_buffalo_request when calling postBuffalo'
            );
        }


        $resourcePath = '/buffalo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_buffalo_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_buffalo_request));
            } else {
                $httpBody = $post_buffalo_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCotton
     *
     * Perform cotton calculation
     *
     * @param  \OpenAPI\Client\Model\PostCottonRequest $post_cotton_request post_cotton_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCotton'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostCotton200Response
     */
    public function postCotton($post_cotton_request, string $contentType = self::contentTypes['postCotton'][0])
    {
        list($response) = $this->postCottonWithHttpInfo($post_cotton_request, $contentType);
        return $response;
    }

    /**
     * Operation postCottonWithHttpInfo
     *
     * Perform cotton calculation
     *
     * @param  \OpenAPI\Client\Model\PostCottonRequest $post_cotton_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCotton'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostCotton200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCottonWithHttpInfo($post_cotton_request, string $contentType = self::contentTypes['postCotton'][0])
    {
        $request = $this->postCottonRequest($post_cotton_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostCotton200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostCotton200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostCotton200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postCottonAsync
     *
     * Perform cotton calculation
     *
     * @param  \OpenAPI\Client\Model\PostCottonRequest $post_cotton_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCotton'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCottonAsync($post_cotton_request, string $contentType = self::contentTypes['postCotton'][0])
    {
        return $this->postCottonAsyncWithHttpInfo($post_cotton_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCottonAsyncWithHttpInfo
     *
     * Perform cotton calculation
     *
     * @param  \OpenAPI\Client\Model\PostCottonRequest $post_cotton_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCotton'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCottonAsyncWithHttpInfo($post_cotton_request, string $contentType = self::contentTypes['postCotton'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostCotton200Response';
        $request = $this->postCottonRequest($post_cotton_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCotton'
     *
     * @param  \OpenAPI\Client\Model\PostCottonRequest $post_cotton_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCotton'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postCottonRequest($post_cotton_request, string $contentType = self::contentTypes['postCotton'][0])
    {

        // verify the required parameter 'post_cotton_request' is set
        if ($post_cotton_request === null || (is_array($post_cotton_request) && count($post_cotton_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_cotton_request when calling postCotton'
            );
        }


        $resourcePath = '/cotton';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_cotton_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_cotton_request));
            } else {
                $httpBody = $post_cotton_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDairy
     *
     * Perform dairy calculation
     *
     * @param  \OpenAPI\Client\Model\PostDairyRequest $post_dairy_request post_dairy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDairy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostDairy200Response
     */
    public function postDairy($post_dairy_request, string $contentType = self::contentTypes['postDairy'][0])
    {
        list($response) = $this->postDairyWithHttpInfo($post_dairy_request, $contentType);
        return $response;
    }

    /**
     * Operation postDairyWithHttpInfo
     *
     * Perform dairy calculation
     *
     * @param  \OpenAPI\Client\Model\PostDairyRequest $post_dairy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDairy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostDairy200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDairyWithHttpInfo($post_dairy_request, string $contentType = self::contentTypes['postDairy'][0])
    {
        $request = $this->postDairyRequest($post_dairy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostDairy200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostDairy200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostDairy200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postDairyAsync
     *
     * Perform dairy calculation
     *
     * @param  \OpenAPI\Client\Model\PostDairyRequest $post_dairy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDairy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDairyAsync($post_dairy_request, string $contentType = self::contentTypes['postDairy'][0])
    {
        return $this->postDairyAsyncWithHttpInfo($post_dairy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDairyAsyncWithHttpInfo
     *
     * Perform dairy calculation
     *
     * @param  \OpenAPI\Client\Model\PostDairyRequest $post_dairy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDairy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDairyAsyncWithHttpInfo($post_dairy_request, string $contentType = self::contentTypes['postDairy'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostDairy200Response';
        $request = $this->postDairyRequest($post_dairy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDairy'
     *
     * @param  \OpenAPI\Client\Model\PostDairyRequest $post_dairy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDairy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postDairyRequest($post_dairy_request, string $contentType = self::contentTypes['postDairy'][0])
    {

        // verify the required parameter 'post_dairy_request' is set
        if ($post_dairy_request === null || (is_array($post_dairy_request) && count($post_dairy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_dairy_request when calling postDairy'
            );
        }


        $resourcePath = '/dairy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_dairy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_dairy_request));
            } else {
                $httpBody = $post_dairy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDeer
     *
     * Perform deer calculation
     *
     * @param  \OpenAPI\Client\Model\PostDeerRequest $post_deer_request post_deer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDeer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostDeer200Response
     */
    public function postDeer($post_deer_request, string $contentType = self::contentTypes['postDeer'][0])
    {
        list($response) = $this->postDeerWithHttpInfo($post_deer_request, $contentType);
        return $response;
    }

    /**
     * Operation postDeerWithHttpInfo
     *
     * Perform deer calculation
     *
     * @param  \OpenAPI\Client\Model\PostDeerRequest $post_deer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDeer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostDeer200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDeerWithHttpInfo($post_deer_request, string $contentType = self::contentTypes['postDeer'][0])
    {
        $request = $this->postDeerRequest($post_deer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostDeer200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostDeer200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostDeer200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postDeerAsync
     *
     * Perform deer calculation
     *
     * @param  \OpenAPI\Client\Model\PostDeerRequest $post_deer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDeer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDeerAsync($post_deer_request, string $contentType = self::contentTypes['postDeer'][0])
    {
        return $this->postDeerAsyncWithHttpInfo($post_deer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDeerAsyncWithHttpInfo
     *
     * Perform deer calculation
     *
     * @param  \OpenAPI\Client\Model\PostDeerRequest $post_deer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDeer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDeerAsyncWithHttpInfo($post_deer_request, string $contentType = self::contentTypes['postDeer'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostDeer200Response';
        $request = $this->postDeerRequest($post_deer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDeer'
     *
     * @param  \OpenAPI\Client\Model\PostDeerRequest $post_deer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postDeer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postDeerRequest($post_deer_request, string $contentType = self::contentTypes['postDeer'][0])
    {

        // verify the required parameter 'post_deer_request' is set
        if ($post_deer_request === null || (is_array($post_deer_request) && count($post_deer_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_deer_request when calling postDeer'
            );
        }


        $resourcePath = '/deer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_deer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_deer_request));
            } else {
                $httpBody = $post_deer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFeedlot
     *
     * Perform feedlot calculation
     *
     * @param  \OpenAPI\Client\Model\PostFeedlotRequest $post_feedlot_request post_feedlot_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postFeedlot'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostFeedlot200Response
     */
    public function postFeedlot($post_feedlot_request, string $contentType = self::contentTypes['postFeedlot'][0])
    {
        list($response) = $this->postFeedlotWithHttpInfo($post_feedlot_request, $contentType);
        return $response;
    }

    /**
     * Operation postFeedlotWithHttpInfo
     *
     * Perform feedlot calculation
     *
     * @param  \OpenAPI\Client\Model\PostFeedlotRequest $post_feedlot_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postFeedlot'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostFeedlot200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFeedlotWithHttpInfo($post_feedlot_request, string $contentType = self::contentTypes['postFeedlot'][0])
    {
        $request = $this->postFeedlotRequest($post_feedlot_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostFeedlot200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostFeedlot200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostFeedlot200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postFeedlotAsync
     *
     * Perform feedlot calculation
     *
     * @param  \OpenAPI\Client\Model\PostFeedlotRequest $post_feedlot_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postFeedlot'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeedlotAsync($post_feedlot_request, string $contentType = self::contentTypes['postFeedlot'][0])
    {
        return $this->postFeedlotAsyncWithHttpInfo($post_feedlot_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFeedlotAsyncWithHttpInfo
     *
     * Perform feedlot calculation
     *
     * @param  \OpenAPI\Client\Model\PostFeedlotRequest $post_feedlot_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postFeedlot'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeedlotAsyncWithHttpInfo($post_feedlot_request, string $contentType = self::contentTypes['postFeedlot'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostFeedlot200Response';
        $request = $this->postFeedlotRequest($post_feedlot_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFeedlot'
     *
     * @param  \OpenAPI\Client\Model\PostFeedlotRequest $post_feedlot_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postFeedlot'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postFeedlotRequest($post_feedlot_request, string $contentType = self::contentTypes['postFeedlot'][0])
    {

        // verify the required parameter 'post_feedlot_request' is set
        if ($post_feedlot_request === null || (is_array($post_feedlot_request) && count($post_feedlot_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_feedlot_request when calling postFeedlot'
            );
        }


        $resourcePath = '/feedlot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_feedlot_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_feedlot_request));
            } else {
                $httpBody = $post_feedlot_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postGoat
     *
     * Perform goat calculation
     *
     * @param  \OpenAPI\Client\Model\PostGoatRequest $post_goat_request post_goat_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGoat'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostGoat200Response
     */
    public function postGoat($post_goat_request, string $contentType = self::contentTypes['postGoat'][0])
    {
        list($response) = $this->postGoatWithHttpInfo($post_goat_request, $contentType);
        return $response;
    }

    /**
     * Operation postGoatWithHttpInfo
     *
     * Perform goat calculation
     *
     * @param  \OpenAPI\Client\Model\PostGoatRequest $post_goat_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGoat'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostGoat200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postGoatWithHttpInfo($post_goat_request, string $contentType = self::contentTypes['postGoat'][0])
    {
        $request = $this->postGoatRequest($post_goat_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostGoat200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostGoat200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostGoat200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postGoatAsync
     *
     * Perform goat calculation
     *
     * @param  \OpenAPI\Client\Model\PostGoatRequest $post_goat_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGoat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGoatAsync($post_goat_request, string $contentType = self::contentTypes['postGoat'][0])
    {
        return $this->postGoatAsyncWithHttpInfo($post_goat_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postGoatAsyncWithHttpInfo
     *
     * Perform goat calculation
     *
     * @param  \OpenAPI\Client\Model\PostGoatRequest $post_goat_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGoat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGoatAsyncWithHttpInfo($post_goat_request, string $contentType = self::contentTypes['postGoat'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostGoat200Response';
        $request = $this->postGoatRequest($post_goat_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postGoat'
     *
     * @param  \OpenAPI\Client\Model\PostGoatRequest $post_goat_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGoat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postGoatRequest($post_goat_request, string $contentType = self::contentTypes['postGoat'][0])
    {

        // verify the required parameter 'post_goat_request' is set
        if ($post_goat_request === null || (is_array($post_goat_request) && count($post_goat_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_goat_request when calling postGoat'
            );
        }


        $resourcePath = '/goat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_goat_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_goat_request));
            } else {
                $httpBody = $post_goat_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postGrains
     *
     * Perform grains calculation
     *
     * @param  \OpenAPI\Client\Model\PostGrainsRequest $post_grains_request post_grains_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGrains'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostGrains200Response
     */
    public function postGrains($post_grains_request, string $contentType = self::contentTypes['postGrains'][0])
    {
        list($response) = $this->postGrainsWithHttpInfo($post_grains_request, $contentType);
        return $response;
    }

    /**
     * Operation postGrainsWithHttpInfo
     *
     * Perform grains calculation
     *
     * @param  \OpenAPI\Client\Model\PostGrainsRequest $post_grains_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGrains'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostGrains200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postGrainsWithHttpInfo($post_grains_request, string $contentType = self::contentTypes['postGrains'][0])
    {
        $request = $this->postGrainsRequest($post_grains_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostGrains200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostGrains200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostGrains200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postGrainsAsync
     *
     * Perform grains calculation
     *
     * @param  \OpenAPI\Client\Model\PostGrainsRequest $post_grains_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGrains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGrainsAsync($post_grains_request, string $contentType = self::contentTypes['postGrains'][0])
    {
        return $this->postGrainsAsyncWithHttpInfo($post_grains_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postGrainsAsyncWithHttpInfo
     *
     * Perform grains calculation
     *
     * @param  \OpenAPI\Client\Model\PostGrainsRequest $post_grains_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGrains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGrainsAsyncWithHttpInfo($post_grains_request, string $contentType = self::contentTypes['postGrains'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostGrains200Response';
        $request = $this->postGrainsRequest($post_grains_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postGrains'
     *
     * @param  \OpenAPI\Client\Model\PostGrainsRequest $post_grains_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGrains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postGrainsRequest($post_grains_request, string $contentType = self::contentTypes['postGrains'][0])
    {

        // verify the required parameter 'post_grains_request' is set
        if ($post_grains_request === null || (is_array($post_grains_request) && count($post_grains_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_grains_request when calling postGrains'
            );
        }


        $resourcePath = '/grains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_grains_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_grains_request));
            } else {
                $httpBody = $post_grains_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postHorticulture
     *
     * Perform horticulture calculation
     *
     * @param  \OpenAPI\Client\Model\PostHorticultureRequest $post_horticulture_request post_horticulture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postHorticulture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostHorticulture200Response
     */
    public function postHorticulture($post_horticulture_request, string $contentType = self::contentTypes['postHorticulture'][0])
    {
        list($response) = $this->postHorticultureWithHttpInfo($post_horticulture_request, $contentType);
        return $response;
    }

    /**
     * Operation postHorticultureWithHttpInfo
     *
     * Perform horticulture calculation
     *
     * @param  \OpenAPI\Client\Model\PostHorticultureRequest $post_horticulture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postHorticulture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostHorticulture200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postHorticultureWithHttpInfo($post_horticulture_request, string $contentType = self::contentTypes['postHorticulture'][0])
    {
        $request = $this->postHorticultureRequest($post_horticulture_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostHorticulture200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostHorticulture200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostHorticulture200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postHorticultureAsync
     *
     * Perform horticulture calculation
     *
     * @param  \OpenAPI\Client\Model\PostHorticultureRequest $post_horticulture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postHorticulture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postHorticultureAsync($post_horticulture_request, string $contentType = self::contentTypes['postHorticulture'][0])
    {
        return $this->postHorticultureAsyncWithHttpInfo($post_horticulture_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postHorticultureAsyncWithHttpInfo
     *
     * Perform horticulture calculation
     *
     * @param  \OpenAPI\Client\Model\PostHorticultureRequest $post_horticulture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postHorticulture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postHorticultureAsyncWithHttpInfo($post_horticulture_request, string $contentType = self::contentTypes['postHorticulture'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostHorticulture200Response';
        $request = $this->postHorticultureRequest($post_horticulture_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postHorticulture'
     *
     * @param  \OpenAPI\Client\Model\PostHorticultureRequest $post_horticulture_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postHorticulture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postHorticultureRequest($post_horticulture_request, string $contentType = self::contentTypes['postHorticulture'][0])
    {

        // verify the required parameter 'post_horticulture_request' is set
        if ($post_horticulture_request === null || (is_array($post_horticulture_request) && count($post_horticulture_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_horticulture_request when calling postHorticulture'
            );
        }


        $resourcePath = '/horticulture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_horticulture_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_horticulture_request));
            } else {
                $httpBody = $post_horticulture_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPork
     *
     * Perform pork calculation
     *
     * @param  \OpenAPI\Client\Model\PostPorkRequest $post_pork_request post_pork_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPork'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostPork200Response
     */
    public function postPork($post_pork_request, string $contentType = self::contentTypes['postPork'][0])
    {
        list($response) = $this->postPorkWithHttpInfo($post_pork_request, $contentType);
        return $response;
    }

    /**
     * Operation postPorkWithHttpInfo
     *
     * Perform pork calculation
     *
     * @param  \OpenAPI\Client\Model\PostPorkRequest $post_pork_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPork'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostPork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPorkWithHttpInfo($post_pork_request, string $contentType = self::contentTypes['postPork'][0])
    {
        $request = $this->postPorkRequest($post_pork_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostPork200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostPork200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostPork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postPorkAsync
     *
     * Perform pork calculation
     *
     * @param  \OpenAPI\Client\Model\PostPorkRequest $post_pork_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPorkAsync($post_pork_request, string $contentType = self::contentTypes['postPork'][0])
    {
        return $this->postPorkAsyncWithHttpInfo($post_pork_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPorkAsyncWithHttpInfo
     *
     * Perform pork calculation
     *
     * @param  \OpenAPI\Client\Model\PostPorkRequest $post_pork_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPorkAsyncWithHttpInfo($post_pork_request, string $contentType = self::contentTypes['postPork'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostPork200Response';
        $request = $this->postPorkRequest($post_pork_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPork'
     *
     * @param  \OpenAPI\Client\Model\PostPorkRequest $post_pork_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPorkRequest($post_pork_request, string $contentType = self::contentTypes['postPork'][0])
    {

        // verify the required parameter 'post_pork_request' is set
        if ($post_pork_request === null || (is_array($post_pork_request) && count($post_pork_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_pork_request when calling postPork'
            );
        }


        $resourcePath = '/pork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_pork_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_pork_request));
            } else {
                $httpBody = $post_pork_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPoultry
     *
     * Perform poultry calculation
     *
     * @param  \OpenAPI\Client\Model\PostPoultryRequest $post_poultry_request post_poultry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPoultry'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostPoultry200Response
     */
    public function postPoultry($post_poultry_request, string $contentType = self::contentTypes['postPoultry'][0])
    {
        list($response) = $this->postPoultryWithHttpInfo($post_poultry_request, $contentType);
        return $response;
    }

    /**
     * Operation postPoultryWithHttpInfo
     *
     * Perform poultry calculation
     *
     * @param  \OpenAPI\Client\Model\PostPoultryRequest $post_poultry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPoultry'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostPoultry200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPoultryWithHttpInfo($post_poultry_request, string $contentType = self::contentTypes['postPoultry'][0])
    {
        $request = $this->postPoultryRequest($post_poultry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostPoultry200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostPoultry200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostPoultry200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postPoultryAsync
     *
     * Perform poultry calculation
     *
     * @param  \OpenAPI\Client\Model\PostPoultryRequest $post_poultry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPoultry'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPoultryAsync($post_poultry_request, string $contentType = self::contentTypes['postPoultry'][0])
    {
        return $this->postPoultryAsyncWithHttpInfo($post_poultry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPoultryAsyncWithHttpInfo
     *
     * Perform poultry calculation
     *
     * @param  \OpenAPI\Client\Model\PostPoultryRequest $post_poultry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPoultry'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPoultryAsyncWithHttpInfo($post_poultry_request, string $contentType = self::contentTypes['postPoultry'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostPoultry200Response';
        $request = $this->postPoultryRequest($post_poultry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPoultry'
     *
     * @param  \OpenAPI\Client\Model\PostPoultryRequest $post_poultry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPoultry'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPoultryRequest($post_poultry_request, string $contentType = self::contentTypes['postPoultry'][0])
    {

        // verify the required parameter 'post_poultry_request' is set
        if ($post_poultry_request === null || (is_array($post_poultry_request) && count($post_poultry_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_poultry_request when calling postPoultry'
            );
        }


        $resourcePath = '/poultry';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_poultry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_poultry_request));
            } else {
                $httpBody = $post_poultry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postProcessing
     *
     * Perform processing calculation
     *
     * @param  \OpenAPI\Client\Model\PostProcessingRequest $post_processing_request post_processing_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postProcessing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostProcessing200Response
     */
    public function postProcessing($post_processing_request, string $contentType = self::contentTypes['postProcessing'][0])
    {
        list($response) = $this->postProcessingWithHttpInfo($post_processing_request, $contentType);
        return $response;
    }

    /**
     * Operation postProcessingWithHttpInfo
     *
     * Perform processing calculation
     *
     * @param  \OpenAPI\Client\Model\PostProcessingRequest $post_processing_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postProcessing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostProcessing200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postProcessingWithHttpInfo($post_processing_request, string $contentType = self::contentTypes['postProcessing'][0])
    {
        $request = $this->postProcessingRequest($post_processing_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostProcessing200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostProcessing200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostProcessing200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postProcessingAsync
     *
     * Perform processing calculation
     *
     * @param  \OpenAPI\Client\Model\PostProcessingRequest $post_processing_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postProcessing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postProcessingAsync($post_processing_request, string $contentType = self::contentTypes['postProcessing'][0])
    {
        return $this->postProcessingAsyncWithHttpInfo($post_processing_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postProcessingAsyncWithHttpInfo
     *
     * Perform processing calculation
     *
     * @param  \OpenAPI\Client\Model\PostProcessingRequest $post_processing_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postProcessing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postProcessingAsyncWithHttpInfo($post_processing_request, string $contentType = self::contentTypes['postProcessing'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostProcessing200Response';
        $request = $this->postProcessingRequest($post_processing_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postProcessing'
     *
     * @param  \OpenAPI\Client\Model\PostProcessingRequest $post_processing_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postProcessing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postProcessingRequest($post_processing_request, string $contentType = self::contentTypes['postProcessing'][0])
    {

        // verify the required parameter 'post_processing_request' is set
        if ($post_processing_request === null || (is_array($post_processing_request) && count($post_processing_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_processing_request when calling postProcessing'
            );
        }


        $resourcePath = '/processing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_processing_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_processing_request));
            } else {
                $httpBody = $post_processing_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRice
     *
     * Perform rice calculation
     *
     * @param  \OpenAPI\Client\Model\PostRiceRequest $post_rice_request post_rice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostRice200Response
     */
    public function postRice($post_rice_request, string $contentType = self::contentTypes['postRice'][0])
    {
        list($response) = $this->postRiceWithHttpInfo($post_rice_request, $contentType);
        return $response;
    }

    /**
     * Operation postRiceWithHttpInfo
     *
     * Perform rice calculation
     *
     * @param  \OpenAPI\Client\Model\PostRiceRequest $post_rice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostRice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRiceWithHttpInfo($post_rice_request, string $contentType = self::contentTypes['postRice'][0])
    {
        $request = $this->postRiceRequest($post_rice_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostRice200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostRice200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostRice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRiceAsync
     *
     * Perform rice calculation
     *
     * @param  \OpenAPI\Client\Model\PostRiceRequest $post_rice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRiceAsync($post_rice_request, string $contentType = self::contentTypes['postRice'][0])
    {
        return $this->postRiceAsyncWithHttpInfo($post_rice_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRiceAsyncWithHttpInfo
     *
     * Perform rice calculation
     *
     * @param  \OpenAPI\Client\Model\PostRiceRequest $post_rice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRiceAsyncWithHttpInfo($post_rice_request, string $contentType = self::contentTypes['postRice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostRice200Response';
        $request = $this->postRiceRequest($post_rice_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRice'
     *
     * @param  \OpenAPI\Client\Model\PostRiceRequest $post_rice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRiceRequest($post_rice_request, string $contentType = self::contentTypes['postRice'][0])
    {

        // verify the required parameter 'post_rice_request' is set
        if ($post_rice_request === null || (is_array($post_rice_request) && count($post_rice_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_rice_request when calling postRice'
            );
        }


        $resourcePath = '/rice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_rice_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_rice_request));
            } else {
                $httpBody = $post_rice_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSheep
     *
     * Perform sheep calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepRequest $post_sheep_request post_sheep_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheep'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostSheep200Response
     */
    public function postSheep($post_sheep_request, string $contentType = self::contentTypes['postSheep'][0])
    {
        list($response) = $this->postSheepWithHttpInfo($post_sheep_request, $contentType);
        return $response;
    }

    /**
     * Operation postSheepWithHttpInfo
     *
     * Perform sheep calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepRequest $post_sheep_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheep'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostSheep200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSheepWithHttpInfo($post_sheep_request, string $contentType = self::contentTypes['postSheep'][0])
    {
        $request = $this->postSheepRequest($post_sheep_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostSheep200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostSheep200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostSheep200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSheepAsync
     *
     * Perform sheep calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepRequest $post_sheep_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSheepAsync($post_sheep_request, string $contentType = self::contentTypes['postSheep'][0])
    {
        return $this->postSheepAsyncWithHttpInfo($post_sheep_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSheepAsyncWithHttpInfo
     *
     * Perform sheep calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepRequest $post_sheep_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSheepAsyncWithHttpInfo($post_sheep_request, string $contentType = self::contentTypes['postSheep'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostSheep200Response';
        $request = $this->postSheepRequest($post_sheep_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSheep'
     *
     * @param  \OpenAPI\Client\Model\PostSheepRequest $post_sheep_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSheepRequest($post_sheep_request, string $contentType = self::contentTypes['postSheep'][0])
    {

        // verify the required parameter 'post_sheep_request' is set
        if ($post_sheep_request === null || (is_array($post_sheep_request) && count($post_sheep_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_sheep_request when calling postSheep'
            );
        }


        $resourcePath = '/sheep';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_sheep_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_sheep_request));
            } else {
                $httpBody = $post_sheep_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSheepbeef
     *
     * Perform sheepbeef calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepbeefRequest $post_sheepbeef_request post_sheepbeef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheepbeef'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostSheepbeef200Response
     */
    public function postSheepbeef($post_sheepbeef_request, string $contentType = self::contentTypes['postSheepbeef'][0])
    {
        list($response) = $this->postSheepbeefWithHttpInfo($post_sheepbeef_request, $contentType);
        return $response;
    }

    /**
     * Operation postSheepbeefWithHttpInfo
     *
     * Perform sheepbeef calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepbeefRequest $post_sheepbeef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheepbeef'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostSheepbeef200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSheepbeefWithHttpInfo($post_sheepbeef_request, string $contentType = self::contentTypes['postSheepbeef'][0])
    {
        $request = $this->postSheepbeefRequest($post_sheepbeef_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostSheepbeef200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostSheepbeef200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostSheepbeef200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSheepbeefAsync
     *
     * Perform sheepbeef calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepbeefRequest $post_sheepbeef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheepbeef'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSheepbeefAsync($post_sheepbeef_request, string $contentType = self::contentTypes['postSheepbeef'][0])
    {
        return $this->postSheepbeefAsyncWithHttpInfo($post_sheepbeef_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSheepbeefAsyncWithHttpInfo
     *
     * Perform sheepbeef calculation
     *
     * @param  \OpenAPI\Client\Model\PostSheepbeefRequest $post_sheepbeef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheepbeef'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSheepbeefAsyncWithHttpInfo($post_sheepbeef_request, string $contentType = self::contentTypes['postSheepbeef'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostSheepbeef200Response';
        $request = $this->postSheepbeefRequest($post_sheepbeef_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSheepbeef'
     *
     * @param  \OpenAPI\Client\Model\PostSheepbeefRequest $post_sheepbeef_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSheepbeef'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSheepbeefRequest($post_sheepbeef_request, string $contentType = self::contentTypes['postSheepbeef'][0])
    {

        // verify the required parameter 'post_sheepbeef_request' is set
        if ($post_sheepbeef_request === null || (is_array($post_sheepbeef_request) && count($post_sheepbeef_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_sheepbeef_request when calling postSheepbeef'
            );
        }


        $resourcePath = '/sheepbeef';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_sheepbeef_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_sheepbeef_request));
            } else {
                $httpBody = $post_sheepbeef_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSugar
     *
     * Perform sugar calculation
     *
     * @param  \OpenAPI\Client\Model\PostSugarRequest $post_sugar_request post_sugar_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSugar'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostSugar200Response
     */
    public function postSugar($post_sugar_request, string $contentType = self::contentTypes['postSugar'][0])
    {
        list($response) = $this->postSugarWithHttpInfo($post_sugar_request, $contentType);
        return $response;
    }

    /**
     * Operation postSugarWithHttpInfo
     *
     * Perform sugar calculation
     *
     * @param  \OpenAPI\Client\Model\PostSugarRequest $post_sugar_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSugar'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostSugar200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSugarWithHttpInfo($post_sugar_request, string $contentType = self::contentTypes['postSugar'][0])
    {
        $request = $this->postSugarRequest($post_sugar_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostSugar200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostSugar200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostSugar200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSugarAsync
     *
     * Perform sugar calculation
     *
     * @param  \OpenAPI\Client\Model\PostSugarRequest $post_sugar_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSugar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSugarAsync($post_sugar_request, string $contentType = self::contentTypes['postSugar'][0])
    {
        return $this->postSugarAsyncWithHttpInfo($post_sugar_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSugarAsyncWithHttpInfo
     *
     * Perform sugar calculation
     *
     * @param  \OpenAPI\Client\Model\PostSugarRequest $post_sugar_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSugar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSugarAsyncWithHttpInfo($post_sugar_request, string $contentType = self::contentTypes['postSugar'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostSugar200Response';
        $request = $this->postSugarRequest($post_sugar_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSugar'
     *
     * @param  \OpenAPI\Client\Model\PostSugarRequest $post_sugar_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSugar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSugarRequest($post_sugar_request, string $contentType = self::contentTypes['postSugar'][0])
    {

        // verify the required parameter 'post_sugar_request' is set
        if ($post_sugar_request === null || (is_array($post_sugar_request) && count($post_sugar_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_sugar_request when calling postSugar'
            );
        }


        $resourcePath = '/sugar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_sugar_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_sugar_request));
            } else {
                $httpBody = $post_sugar_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postVineyard
     *
     * Perform vineyard calculation
     *
     * @param  \OpenAPI\Client\Model\PostVineyardRequest $post_vineyard_request post_vineyard_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postVineyard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostVineyard200Response
     */
    public function postVineyard($post_vineyard_request, string $contentType = self::contentTypes['postVineyard'][0])
    {
        list($response) = $this->postVineyardWithHttpInfo($post_vineyard_request, $contentType);
        return $response;
    }

    /**
     * Operation postVineyardWithHttpInfo
     *
     * Perform vineyard calculation
     *
     * @param  \OpenAPI\Client\Model\PostVineyardRequest $post_vineyard_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postVineyard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostVineyard200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postVineyardWithHttpInfo($post_vineyard_request, string $contentType = self::contentTypes['postVineyard'][0])
    {
        $request = $this->postVineyardRequest($post_vineyard_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostVineyard200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostVineyard200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostVineyard200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postVineyardAsync
     *
     * Perform vineyard calculation
     *
     * @param  \OpenAPI\Client\Model\PostVineyardRequest $post_vineyard_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postVineyard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postVineyardAsync($post_vineyard_request, string $contentType = self::contentTypes['postVineyard'][0])
    {
        return $this->postVineyardAsyncWithHttpInfo($post_vineyard_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postVineyardAsyncWithHttpInfo
     *
     * Perform vineyard calculation
     *
     * @param  \OpenAPI\Client\Model\PostVineyardRequest $post_vineyard_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postVineyard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postVineyardAsyncWithHttpInfo($post_vineyard_request, string $contentType = self::contentTypes['postVineyard'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostVineyard200Response';
        $request = $this->postVineyardRequest($post_vineyard_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postVineyard'
     *
     * @param  \OpenAPI\Client\Model\PostVineyardRequest $post_vineyard_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postVineyard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postVineyardRequest($post_vineyard_request, string $contentType = self::contentTypes['postVineyard'][0])
    {

        // verify the required parameter 'post_vineyard_request' is set
        if ($post_vineyard_request === null || (is_array($post_vineyard_request) && count($post_vineyard_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_vineyard_request when calling postVineyard'
            );
        }


        $resourcePath = '/vineyard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_vineyard_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_vineyard_request));
            } else {
                $httpBody = $post_vineyard_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postWildcatchfishery
     *
     * Perform wildcatchfishery calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildcatchfisheryRequest $post_wildcatchfishery_request post_wildcatchfishery_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildcatchfishery'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostWildcatchfishery200Response
     */
    public function postWildcatchfishery($post_wildcatchfishery_request, string $contentType = self::contentTypes['postWildcatchfishery'][0])
    {
        list($response) = $this->postWildcatchfisheryWithHttpInfo($post_wildcatchfishery_request, $contentType);
        return $response;
    }

    /**
     * Operation postWildcatchfisheryWithHttpInfo
     *
     * Perform wildcatchfishery calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildcatchfisheryRequest $post_wildcatchfishery_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildcatchfishery'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostWildcatchfishery200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postWildcatchfisheryWithHttpInfo($post_wildcatchfishery_request, string $contentType = self::contentTypes['postWildcatchfishery'][0])
    {
        $request = $this->postWildcatchfisheryRequest($post_wildcatchfishery_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostWildcatchfishery200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostWildcatchfishery200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostWildcatchfishery200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postWildcatchfisheryAsync
     *
     * Perform wildcatchfishery calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildcatchfisheryRequest $post_wildcatchfishery_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildcatchfishery'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWildcatchfisheryAsync($post_wildcatchfishery_request, string $contentType = self::contentTypes['postWildcatchfishery'][0])
    {
        return $this->postWildcatchfisheryAsyncWithHttpInfo($post_wildcatchfishery_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postWildcatchfisheryAsyncWithHttpInfo
     *
     * Perform wildcatchfishery calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildcatchfisheryRequest $post_wildcatchfishery_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildcatchfishery'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWildcatchfisheryAsyncWithHttpInfo($post_wildcatchfishery_request, string $contentType = self::contentTypes['postWildcatchfishery'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostWildcatchfishery200Response';
        $request = $this->postWildcatchfisheryRequest($post_wildcatchfishery_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postWildcatchfishery'
     *
     * @param  \OpenAPI\Client\Model\PostWildcatchfisheryRequest $post_wildcatchfishery_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildcatchfishery'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postWildcatchfisheryRequest($post_wildcatchfishery_request, string $contentType = self::contentTypes['postWildcatchfishery'][0])
    {

        // verify the required parameter 'post_wildcatchfishery_request' is set
        if ($post_wildcatchfishery_request === null || (is_array($post_wildcatchfishery_request) && count($post_wildcatchfishery_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_wildcatchfishery_request when calling postWildcatchfishery'
            );
        }


        $resourcePath = '/wildcatchfishery';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_wildcatchfishery_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_wildcatchfishery_request));
            } else {
                $httpBody = $post_wildcatchfishery_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postWildseafisheries
     *
     * Perform wildseafisheries calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildseafisheriesRequest $post_wildseafisheries_request post_wildseafisheries_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildseafisheries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostWildseafisheries200Response
     */
    public function postWildseafisheries($post_wildseafisheries_request, string $contentType = self::contentTypes['postWildseafisheries'][0])
    {
        list($response) = $this->postWildseafisheriesWithHttpInfo($post_wildseafisheries_request, $contentType);
        return $response;
    }

    /**
     * Operation postWildseafisheriesWithHttpInfo
     *
     * Perform wildseafisheries calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildseafisheriesRequest $post_wildseafisheries_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildseafisheries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostWildseafisheries200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postWildseafisheriesWithHttpInfo($post_wildseafisheries_request, string $contentType = self::contentTypes['postWildseafisheries'][0])
    {
        $request = $this->postWildseafisheriesRequest($post_wildseafisheries_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PostWildseafisheries200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PostWildseafisheries200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostWildseafisheries200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postWildseafisheriesAsync
     *
     * Perform wildseafisheries calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildseafisheriesRequest $post_wildseafisheries_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildseafisheries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWildseafisheriesAsync($post_wildseafisheries_request, string $contentType = self::contentTypes['postWildseafisheries'][0])
    {
        return $this->postWildseafisheriesAsyncWithHttpInfo($post_wildseafisheries_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postWildseafisheriesAsyncWithHttpInfo
     *
     * Perform wildseafisheries calculation
     *
     * @param  \OpenAPI\Client\Model\PostWildseafisheriesRequest $post_wildseafisheries_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildseafisheries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWildseafisheriesAsyncWithHttpInfo($post_wildseafisheries_request, string $contentType = self::contentTypes['postWildseafisheries'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostWildseafisheries200Response';
        $request = $this->postWildseafisheriesRequest($post_wildseafisheries_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postWildseafisheries'
     *
     * @param  \OpenAPI\Client\Model\PostWildseafisheriesRequest $post_wildseafisheries_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postWildseafisheries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postWildseafisheriesRequest($post_wildseafisheries_request, string $contentType = self::contentTypes['postWildseafisheries'][0])
    {

        // verify the required parameter 'post_wildseafisheries_request' is set
        if ($post_wildseafisheries_request === null || (is_array($post_wildseafisheries_request) && count($post_wildseafisheries_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_wildseafisheries_request when calling postWildseafisheries'
            );
        }


        $resourcePath = '/wildseafisheries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_wildseafisheries_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_wildseafisheries_request));
            } else {
                $httpBody = $post_wildseafisheries_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
