# coding: utf-8

"""
    AIA Calculator API

    Emissions Calculators for various farming activities

    The version of the OpenAPI document: 3.0.0
    Contact: contact@aginnovationaustralia.com.au
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.post_deer_request_deers_inner_classes_breeding_does import PostDeerRequestDeersInnerClassesBreedingDoes
from openapi_client.models.post_deer_request_deers_inner_classes_bucks import PostDeerRequestDeersInnerClassesBucks
from openapi_client.models.post_deer_request_deers_inner_classes_fawn import PostDeerRequestDeersInnerClassesFawn
from openapi_client.models.post_deer_request_deers_inner_classes_other_does import PostDeerRequestDeersInnerClassesOtherDoes
from openapi_client.models.post_deer_request_deers_inner_classes_trade_bucks import PostDeerRequestDeersInnerClassesTradeBucks
from openapi_client.models.post_deer_request_deers_inner_classes_trade_does import PostDeerRequestDeersInnerClassesTradeDoes
from openapi_client.models.post_deer_request_deers_inner_classes_trade_fawn import PostDeerRequestDeersInnerClassesTradeFawn
from openapi_client.models.post_deer_request_deers_inner_classes_trade_other_does import PostDeerRequestDeersInnerClassesTradeOtherDoes
from typing import Optional, Set
from typing_extensions import Self

class PostDeerRequestDeersInnerClasses(BaseModel):
    """
    Deer classes of different types
    """ # noqa: E501
    bucks: Optional[PostDeerRequestDeersInnerClassesBucks] = None
    trade_bucks: Optional[PostDeerRequestDeersInnerClassesTradeBucks] = Field(default=None, alias="tradeBucks")
    breeding_does: Optional[PostDeerRequestDeersInnerClassesBreedingDoes] = Field(default=None, alias="breedingDoes")
    trade_does: Optional[PostDeerRequestDeersInnerClassesTradeDoes] = Field(default=None, alias="tradeDoes")
    other_does: Optional[PostDeerRequestDeersInnerClassesOtherDoes] = Field(default=None, alias="otherDoes")
    trade_other_does: Optional[PostDeerRequestDeersInnerClassesTradeOtherDoes] = Field(default=None, alias="tradeOtherDoes")
    fawn: Optional[PostDeerRequestDeersInnerClassesFawn] = None
    trade_fawn: Optional[PostDeerRequestDeersInnerClassesTradeFawn] = Field(default=None, alias="tradeFawn")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["bucks", "tradeBucks", "breedingDoes", "tradeDoes", "otherDoes", "tradeOtherDoes", "fawn", "tradeFawn"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostDeerRequestDeersInnerClasses from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of bucks
        if self.bucks:
            _dict['bucks'] = self.bucks.to_dict()
        # override the default output from pydantic by calling `to_dict()` of trade_bucks
        if self.trade_bucks:
            _dict['tradeBucks'] = self.trade_bucks.to_dict()
        # override the default output from pydantic by calling `to_dict()` of breeding_does
        if self.breeding_does:
            _dict['breedingDoes'] = self.breeding_does.to_dict()
        # override the default output from pydantic by calling `to_dict()` of trade_does
        if self.trade_does:
            _dict['tradeDoes'] = self.trade_does.to_dict()
        # override the default output from pydantic by calling `to_dict()` of other_does
        if self.other_does:
            _dict['otherDoes'] = self.other_does.to_dict()
        # override the default output from pydantic by calling `to_dict()` of trade_other_does
        if self.trade_other_does:
            _dict['tradeOtherDoes'] = self.trade_other_does.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fawn
        if self.fawn:
            _dict['fawn'] = self.fawn.to_dict()
        # override the default output from pydantic by calling `to_dict()` of trade_fawn
        if self.trade_fawn:
            _dict['tradeFawn'] = self.trade_fawn.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostDeerRequestDeersInnerClasses from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bucks": PostDeerRequestDeersInnerClassesBucks.from_dict(obj["bucks"]) if obj.get("bucks") is not None else None,
            "tradeBucks": PostDeerRequestDeersInnerClassesTradeBucks.from_dict(obj["tradeBucks"]) if obj.get("tradeBucks") is not None else None,
            "breedingDoes": PostDeerRequestDeersInnerClassesBreedingDoes.from_dict(obj["breedingDoes"]) if obj.get("breedingDoes") is not None else None,
            "tradeDoes": PostDeerRequestDeersInnerClassesTradeDoes.from_dict(obj["tradeDoes"]) if obj.get("tradeDoes") is not None else None,
            "otherDoes": PostDeerRequestDeersInnerClassesOtherDoes.from_dict(obj["otherDoes"]) if obj.get("otherDoes") is not None else None,
            "tradeOtherDoes": PostDeerRequestDeersInnerClassesTradeOtherDoes.from_dict(obj["tradeOtherDoes"]) if obj.get("tradeOtherDoes") is not None else None,
            "fawn": PostDeerRequestDeersInnerClassesFawn.from_dict(obj["fawn"]) if obj.get("fawn") is not None else None,
            "tradeFawn": PostDeerRequestDeersInnerClassesTradeFawn.from_dict(obj["tradeFawn"]) if obj.get("tradeFawn") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


