# coding: utf-8

"""
    AIA Calculator API

    Emissions Calculators for various farming activities

    The version of the OpenAPI document: 3.0.0
    Contact: contact@aginnovationaustralia.com.au
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PostRiceRequestCropsInner(BaseModel):
    """
    PostRiceRequestCropsInner
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Unique identifier for this activity")
    state: StrictStr = Field(description="What state the location is in. Note: Western Australia is split up into two regions, `wa_nw` is North-West Western Australia, `wa_sw` is South-West Western Australia")
    average_rice_yield: Union[StrictFloat, StrictInt] = Field(description="Average rice yield, in t/ha (tonnes per hectare)", alias="averageRiceYield")
    area_sown: Union[StrictFloat, StrictInt] = Field(description="Area sown, in ha (hectares)", alias="areaSown")
    growing_season_days: Union[StrictFloat, StrictInt] = Field(description="The length of the growing season for this crop, in days", alias="growingSeasonDays")
    water_regime_type: StrictStr = Field(alias="waterRegimeType")
    water_regime_sub_type: StrictStr = Field(alias="waterRegimeSubType")
    rice_preseason_flooding_period: StrictStr = Field(alias="ricePreseasonFloodingPeriod")
    urea_application: Union[StrictFloat, StrictInt] = Field(description="Urea application, in kg Urea/ha (kilograms of urea per hectare)", alias="ureaApplication")
    non_urea_nitrogen: Union[StrictFloat, StrictInt] = Field(description="Non-urea nitrogen application, in kg N/ha (kilograms of nitrogen per hectare)", alias="nonUreaNitrogen")
    urea_ammonium_nitrate: Union[StrictFloat, StrictInt] = Field(description="Urea-Ammonium nitrate application, in kg product/ha (kilograms of product per hectare)", alias="ureaAmmoniumNitrate")
    phosphorus_application: Union[StrictFloat, StrictInt] = Field(description="Phosphorus application, in kg P/ha (kilograms of phosphorus per hectare)", alias="phosphorusApplication")
    potassium_application: Union[StrictFloat, StrictInt] = Field(description="Potassium application, in kg K/ha (kilograms of potassium per hectare)", alias="potassiumApplication")
    sulfur_application: Union[StrictFloat, StrictInt] = Field(description="Sulfur application, in kg S/ha (kilograms of sulfur per hectare)", alias="sulfurApplication")
    fraction_of_annual_crop_burnt: Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]] = Field(description="Fraction of annual production of crop that is burnt, from 0 to 1", alias="fractionOfAnnualCropBurnt")
    herbicide_use: Union[StrictFloat, StrictInt] = Field(description="Total amount of active ingredients from general herbicide/pesticide use, in kg (kilogram)", alias="herbicideUse")
    glyphosate_other_herbicide_use: Union[StrictFloat, StrictInt] = Field(description="Total amount of active ingredients from other herbicide use (Paraquat, Diquat, Glyphosate), in kg (kilogram)", alias="glyphosateOtherHerbicideUse")
    electricity_allocation: Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]] = Field(description="Percentage of electricity use to allocate to this crop, from 0 to 1", alias="electricityAllocation")
    limestone: Union[StrictFloat, StrictInt] = Field(description="Lime applied in tonnes")
    limestone_fraction: Union[StrictFloat, StrictInt] = Field(description="Fraction of lime as limestone vs dolomite, between 0 and 1", alias="limestoneFraction")
    diesel_use: Union[StrictFloat, StrictInt] = Field(description="Diesel usage in L (litres)", alias="dieselUse")
    petrol_use: Union[StrictFloat, StrictInt] = Field(description="Petrol usage in L (litres)", alias="petrolUse")
    lpg: Union[StrictFloat, StrictInt] = Field(description="LPG Fuel usage in L (litres)")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["id", "state", "averageRiceYield", "areaSown", "growingSeasonDays", "waterRegimeType", "waterRegimeSubType", "ricePreseasonFloodingPeriod", "ureaApplication", "nonUreaNitrogen", "ureaAmmoniumNitrate", "phosphorusApplication", "potassiumApplication", "sulfurApplication", "fractionOfAnnualCropBurnt", "herbicideUse", "glyphosateOtherHerbicideUse", "electricityAllocation", "limestone", "limestoneFraction", "dieselUse", "petrolUse", "lpg"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['nsw', 'vic', 'qld', 'sa', 'wa_nw', 'wa_sw', 'tas', 'nt', 'act']):
            raise ValueError("must be one of enum values ('nsw', 'vic', 'qld', 'sa', 'wa_nw', 'wa_sw', 'tas', 'nt', 'act')")
        return value

    @field_validator('water_regime_type')
    def water_regime_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Upland', 'Irrigated', 'Rainfed']):
            raise ValueError("must be one of enum values ('Upland', 'Irrigated', 'Rainfed')")
        return value

    @field_validator('water_regime_sub_type')
    def water_regime_sub_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Continuously flooded', 'Single drainage period', 'Multiple drainage periods', 'Regular rainfed', 'Drought prone', 'Deep water', 'Paddy rotation', 'Fallow without flooding in previous year']):
            raise ValueError("must be one of enum values ('Continuously flooded', 'Single drainage period', 'Multiple drainage periods', 'Regular rainfed', 'Drought prone', 'Deep water', 'Paddy rotation', 'Fallow without flooding in previous year')")
        return value

    @field_validator('rice_preseason_flooding_period')
    def rice_preseason_flooding_period_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Non flooded pre-season < 180 days', 'Non flooded pre-season > 180 days', 'Flooded pre-season > 30 days', 'Non-flooded pre-season > 365 days']):
            raise ValueError("must be one of enum values ('Non flooded pre-season < 180 days', 'Non flooded pre-season > 180 days', 'Flooded pre-season > 30 days', 'Non-flooded pre-season > 365 days')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostRiceRequestCropsInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostRiceRequestCropsInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "state": obj.get("state"),
            "averageRiceYield": obj.get("averageRiceYield"),
            "areaSown": obj.get("areaSown"),
            "growingSeasonDays": obj.get("growingSeasonDays"),
            "waterRegimeType": obj.get("waterRegimeType"),
            "waterRegimeSubType": obj.get("waterRegimeSubType"),
            "ricePreseasonFloodingPeriod": obj.get("ricePreseasonFloodingPeriod"),
            "ureaApplication": obj.get("ureaApplication"),
            "nonUreaNitrogen": obj.get("nonUreaNitrogen"),
            "ureaAmmoniumNitrate": obj.get("ureaAmmoniumNitrate"),
            "phosphorusApplication": obj.get("phosphorusApplication"),
            "potassiumApplication": obj.get("potassiumApplication"),
            "sulfurApplication": obj.get("sulfurApplication"),
            "fractionOfAnnualCropBurnt": obj.get("fractionOfAnnualCropBurnt"),
            "herbicideUse": obj.get("herbicideUse"),
            "glyphosateOtherHerbicideUse": obj.get("glyphosateOtherHerbicideUse"),
            "electricityAllocation": obj.get("electricityAllocation"),
            "limestone": obj.get("limestone"),
            "limestoneFraction": obj.get("limestoneFraction"),
            "dieselUse": obj.get("dieselUse"),
            "petrolUse": obj.get("petrolUse"),
            "lpg": obj.get("lpg")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


